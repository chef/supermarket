# Nginx configuration for Supermarket's Rails app
#
# Generated by Chef

upstream rails {
  server 127.0.0.1:{{ bind.rails.first.cfg.port }};
}

{{ #if cfg.cache.enable ~}}
proxy_cache_path {{ pkg.svc_var_path }}/cache levels=1:2 keys_zone=supermarket-cache:512m max_size=1000m inactive=600m;
proxy_temp_path  {{ pkg.svc_var_path }};

log_format cache '$remote_addr - [$time_local] "$request" $upstream_cache_status $upstream_response_time $upstream_status';
{{ /if ~}}

server {
  listen      {{ bind.rails.first.cfg.http-port }} default_server;
  server_name {{ bind.rails.first.cfg.fqdn }};
  {{ #if bind.rails.first.cfg.force-ssl ~}}
  {{ #with cfg.ssl ~}}
  location / {
    if ($http_x_forwarded_proto != 'https') {
      return 301 https://$server_name$request_uri;
    }
  }
}

server {
  listen      {{ ../bind.rails.first.cfg.https-port }}{{ #if enabled }} ssl{{ /if }};
  server_name {{ ../bind.rails.first.cfg.fqdn }};

  {{ #if enabled ~}}
  ssl_certificate           {{ certificate }};
  ssl_certificate_key       {{ certificate_key }};
  {{~ #if ssl_dhparam }}
  ssl_dhparam               {{ ssl_dhparam }};
  {{~ /if }}
  ssl_prefer_server_ciphers on;
  ssl_ciphers               {{ #if ../cfg.fips.enabled }}{{ ../cfg.fips.ciphers }}{{ else }}{{ ciphers }}{{ /if }};
  ssl_protocols             {{ protocols }};
  ssl_session_cache         {{ session_cache }};
  ssl_session_timeout       {{ session_timeout }};
  {{~ /if }}
  {{~ /with }}
    {{~ /if }}

  {{ #if cfg.redirect_to_canonical ~}}
  set $redirect_to_canonical 0;

  # Redirect anything that isn't an ip address (for ELB checks) or the
  # canonical server name to {{ bind.rails.first.cfg.fqdn }}
  if ($host !~* "^({{ bind.rails.first.cfg.fqdn-sanitized }}|[0-9.]+)$") {
    set $redirect_to_canonical H;
  }

  # Faraday is the user agent of old berkshelf clients that
  # redirecting broke in the past, detect it so we can redirect
  # accordingly
  if ($http_user_agent ~ 'Faraday') {
    set $redirect_to_canonical 0;
  }

  # This stops redirects for knife supermarket share, which uses net/http,
  # and thus 'Ruby' as the user agent.
  if ($http_user_agent ~ 'Ruby') {
    set $redirect_to_canonical 0;
  }

  if ($redirect_to_canonical = H) {
    return 301 http{{ #if bind.rails.first.cfg.force-ssl }}s{{ /if }}://{{ bind.rails.first.cfg.fqdn }}$request_uri;
  }
  {{~ /if }}

  {{~ #if cfg.cache.enabled }}
  access_log {{ #if cfg.log_directory }}{{ cfg.log_directory }}{{ else }}{{ pkg.svc_path }}/logs{{ /if }}/cache.log cache;
  {{~ /if }}

  location ~ /sitemap\d*.xml.gz {
    root /hab/pkgs/{{ bind.rails.first.package }}/app/public;
    break;
  }

  location ~ ^/(assets|system)/ {
    root       /hab/pkgs/{{ bind.rails.first.package }}/app/public;
    expires    1y;
    add_header Cache-Control public;
    add_header ETag "";
    break;
  }

  location ~ ^/curry/ {
    return 410;
  }

  {{ #if cfg.cache.enable ~}}
  location ~ ^/api/v1/cookbooks/.*/versions/.*(/download)?$ {
    proxy_set_header HOST $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
    proxy_pass       http://rails;
    proxy_redirect   off;

    proxy_ignore_headers Set-Cookie Cache-Control;
    proxy_buffering      on;

    proxy_cache         supermarket-cache;
    proxy_cache_valid   200 302 240m;
    proxy_cache_valid   any     5m;
    expires             240m;

    # to serve gzipped text and json responses
    gzip         on;
    gzip_proxied expired no-cache no-store private auth;
  }
  {{ /if ~}}

  location / {
    proxy_set_header HOST $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header X-Forwarded-Proto https;
    proxy_pass       http://rails;
    proxy_redirect   off;

    # to serve gzipped text and json responses
    gzip            on;
    gzip_min_length 1000;
    gzip_proxied    expired no-cache no-store private auth;
    gzip_types      text/plain application/json;
  }
}
